KERNEL_FILE <- "kernel.cu"
KERNEL_START <- "// [[Kernel.start]]"
KERNEL_END <- "// [[Kernel.end]]"
ITER_LENS_START <- "// [[Iter.lens::start]]"
ITER_LENS_END <- "// [[Iter.lens::end]]"
EXPR_LENS_START <- "// [[Expr.lens::start]]"
EXPR_LENS_END <- "// [[Expr.lens::end]]"
INT_EVAL_START <- "// [[Int.evals::start]]"
INT_EVAL_END <- "// [[Int.evals::end]]"
MAX_LOOPS <- 10
MAX_EXPRS <- 50
MAX_INT_EVAL <- 50
START_FLAG <- -1
END_FLAG <- 1
OTHER_FLAG <- 0
LEN_TYPE <- 0
RDIM_TYPE <- 1
CDIM_TYPE <- 2
GPU_MAPPING <- "gpu_vars"
CPU_MAPPING <- "g_vars"
GPU_INTERMEDIATE_EVAL_MAPPING <- "gpu_int_evals"
CPU_INTERMEDIATE_EVAL_MAPPING <- "g_int_evals"
DATA_FIELD <- "data"
GRID_ID <- "grid_index"
THREAD_ID <- "thread_index"
DEFAULT_INDEX <- "DEFAULT_DATA_INDEX"
DATA_LENGTH <- "len"
DELIM <- " "
OPEN_EXPR <- "("
CLOSE_EXPR <- ")"
SYNC_GRID <- "grid.sync();"
SHARED_MEM_INDEX <- "_shared_mem_index"
EVAL_DATA_INDEX <- "_eval_data_index"
DATA_EVAL <- "_eval_for_data"
REF_EVAL <- "_eval_for_reference"

DEFAULT_DEPTH <- 1

RAW_MATH_FUNS <- paste0(OPEN_EXPR, c("+", "-", "*", "/"))
NEGATIVE_INDEX <- 2
PARSED_MATH_FUNS <- c("add", "sub", "mul", "dvs")

RAW_RANGE_FUN <- paste0(OPEN_EXPR, ":")
PARSED_RANGE_FUN <- "range"

RAW_MAT_MUL_FUN <- paste0(OPEN_EXPR, "%*%")
PARSED_MAT_MUL_FUN <- "mat_mul"

RAW_TRANSPOSE_FUN <- paste0(OPEN_EXPR, "t")
PARSED_TRANSPOSE_FUN <- "transpose"

RAW_ASSIGN_FUN <- paste0(OPEN_EXPR, "<-")
PARSED_ASSIGN_FUN <- "="

RAW_FOR_FUN <- paste0(OPEN_EXPR, "for")
PARSED_FOR_FUN <- "for"

RAW_MULTI_EXPR_FUN <- paste0(OPEN_EXPR, "{")

STORE_RESULT <- "evals";
THREADS_PER_BLOCK <- "THREADS_PER_BLOCK"
EVALS_PER_THREAD <- "gpu_evals_per_thread"

# Writes kernel code to the relevant section of kernel.cu
write_kernel <- function(expr_ls, var_names) {
  # get location of compile directory
  compile_path <- system.file("compile", package = "GPUrun")
  
  # get location of kernel file
  kernel_path <- file.path(compile_path, PSEUDO_NAME, "src", KERNEL_FILE)
  
  # read the kernel file
  kernel_lines <- base::readLines(kernel_path)

  # identify starting and stopping index of kernel text location
  mapped_matches <- as.vector(lapply(kernel_lines, kernel_match))
  start_index <- which(mapped_matches == START_FLAG)
  stop_index <- which(mapped_matches == END_FLAG)

  # Initialize the count of loops in the current commands, and the expressions
  # used to parse the iteration lengths
  init_iter_loop(var_names)
  
  # Initialize the lengths of the exprs in the current commands, and the expressions
  # used to parse the expr lengths
  init_expr_lens(var_names)
  
  # Initialize the global variables used to track intermediate evaluation Rvars
  init_int_evals(var_names)
  
  # Write the parsed expressions to fill in the kernel code
  lines_to_write <- c(kernel_lines[1:start_index])
  for (i in seq_along(expr_ls)) {
    comment_delimeter <- paste0("/* Expression ", as.character(i), " code below */")
    lines_to_write <- c(lines_to_write, indent_lines(c(comment_delimeter, write_expr(expr_ls[[i]], var_names)), 
                                                     DEFAULT_DEPTH),
                        indent_lines(SYNC_GRID, DEFAULT_DEPTH))
  }
  
  # Write the dimensions of the intermediate evaluation Rvar structures
  post_kernel_lines <- write_int_eval_vars(kernel_lines[stop_index:length(kernel_lines)], var_names,
                                           g_int_eval_env$g_int_eval_lens, g_int_eval_env$g_int_eval_rdims,
                                           g_int_eval_env$g_int_eval_cdims, g_int_eval_env$g_int_eval_count)
  
  # Write the iteration expressions to the kernel code to allow initialization of loop lengths 
  post_kernel_lines <- write_iter_loop_lens(post_kernel_lines, 
                                            var_names, g_loop_env$g_loop_exprs, g_loop_env$g_loop_count)
  
  # Write the expression lengths and by extension the number of evaluations per 
  # thread to the initialization function, initialize_expr_lens()
  post_kernel_lines <- write_expr_eval_lens(post_kernel_lines, var_names,
                                            g_expr_env$g_expr_lens, g_expr_env$g_expr_count)

  # Combine all lines to write to output
  lines_to_write <- c(lines_to_write, post_kernel_lines)
  
  # write the updated lines to the kernel file
  base::writeLines(lines_to_write, kernel_path)
}


##########################
#### CONDENSE THE NEXT 2
##########################

# Update the text associated with the iteration loop lengths to have the text 
# generated by machine parsing of the relevant expressions 
write_iter_loop_lens <- function(lines_to_edit, var_names, g_loop_exprs, g_loop_count) {
  
  # identify starting and stopping index of kernel text location
  mapped_matches <- as.vector(lapply(lines_to_edit, iter_lens_match))
  start_index <- which(mapped_matches == START_FLAG)
  stop_index <- which(mapped_matches == END_FLAG)
  
  updated_lines <- c()
  if (g_loop_count > 0) {
    for (i in 1:g_loop_count) {
      updated_lines <- c(updated_lines, 
                         paste0("g_iter_lens[", as.character(i - 1), "] = ",
                                g_loop_exprs[i]))
    }
  }
  updated_lines <- c(updated_lines, paste0("g_iter_count = ", as.character(g_loop_count)))
  
  inserted_lines <- c(lines_to_edit[1:start_index],
                      indent_lines(paste0(updated_lines, ";"), 1),
                      lines_to_edit[stop_index:length(lines_to_edit)])
  return(inserted_lines)
}

# Update the text associated with the expression lengths to have the text 
# generated by machine parsing of the relevant expressions 
write_expr_eval_lens <- function(lines_to_edit, var_names, g_expr_lens, g_expr_count) {
  
  # identify starting and stopping index of kernel text location
  mapped_matches <- as.vector(lapply(lines_to_edit, expr_lens_match))
  start_index <- which(mapped_matches == START_FLAG)
  stop_index <- which(mapped_matches == END_FLAG)
  
  updated_lines <- c()
  if (g_expr_count > 0) {
    for (i in 1:g_expr_count) {
      updated_lines <- c(updated_lines,
                         paste0("expr_len = ", g_expr_lens[i]),
                         paste0("g_evals_per_thread[", as.character(i - 1), "] = ",
                                "std::ceil((float) expr_len / grid_size)"))
    }
  }
  updated_lines <- c(updated_lines, paste0("g_expr_count = ", as.character(g_expr_count)))
  
  inserted_lines <- c(lines_to_edit[1:start_index],
                      indent_lines(paste0(updated_lines, ";"), 1),
                      lines_to_edit[stop_index:length(lines_to_edit)])
  return(inserted_lines)
}

# Update the text associated with the intermediate evaluations to have the text 
# generated by machine parsing of the relevant expressions 
write_int_eval_vars <- function(lines_to_edit, var_names, g_int_eval_lens,
                                g_int_eval_rdims, g_int_eval_cdims, g_int_eval_count) {
  
  # identify starting and stopping index of kernel text location
  mapped_matches <- as.vector(lapply(lines_to_edit, int_eval_match))
  start_index <- which(mapped_matches == START_FLAG)
  stop_index <- which(mapped_matches == END_FLAG)
  
  updated_lines <- c()
  if (g_int_eval_count > 0) {
    for (i in 1:g_int_eval_count) {
      var_inits <- c(".data = (double*) malloc_device(sizeof(double) * len),",
                     ".len = len,",
                     paste0(".rdim = ", g_int_eval_rdims[i], ","),
                     paste0(".cdim = ", g_int_eval_cdims[i]))
      var_inits <- c(indent_lines(var_inits), "};")
      updated_lines <- c(updated_lines,
                         paste0("len = ", g_int_eval_lens[i], ";"),
                         paste0("g_int_evals[",as.character(i - 1) ,"] = {"),
                         var_inits)
    }
  }
  updated_lines <- c(updated_lines, paste0("g_int_eval_count = ", as.character(g_int_eval_count), ";"))
  
  inserted_lines <- c(lines_to_edit[1:start_index],
                      indent_lines(updated_lines, 1),
                      lines_to_edit[stop_index:length(lines_to_edit)])
  return(inserted_lines)
}

##########################
##########################

##########################
#### CONDENSE THE NEXT 3
##########################

kernel_match <- function(input_str) {
  if (grepl(KERNEL_START, input_str, fixed = TRUE)) {
    return(START_FLAG)
  }
  if (grepl(KERNEL_END, input_str, fixed = TRUE)) {
    return(END_FLAG)
  }
  return(OTHER_FLAG);
}

iter_lens_match <- function(input_str) {
  if (grepl(ITER_LENS_START, input_str, fixed = TRUE)) {
    return(START_FLAG)
  }
  if (grepl(ITER_LENS_END, input_str, fixed = TRUE)) {
    return(END_FLAG)
  }
  return(OTHER_FLAG);
}

expr_lens_match <- function(input_str) {
  if (grepl(EXPR_LENS_START, input_str, fixed = TRUE)) {
    return(START_FLAG)
  }
  if (grepl(EXPR_LENS_END, input_str, fixed = TRUE)) {
    return(END_FLAG)
  }
  return(OTHER_FLAG);
}

int_eval_match <- function(input_str) {
  if (grepl(INT_EVAL_START, input_str, fixed = TRUE)) {
    return(START_FLAG)
  }
  if (grepl(INT_EVAL_END, input_str, fixed = TRUE)) {
    return(END_FLAG)
  }
  return(OTHER_FLAG);
}

##########################
##########################

indent_lines <- function(lines, depth) {
  indent <- paste(rep("  ", depth), collapse = "")
  return(paste0(indent, lines))
}

write_expr <- function(expr, var_names) {

  expr_char_vec <- paste0(GPUrun::racket_char_vec(expr), collapse = "")
  parsed_lines <- parse_expr(expr_char_vec, var_names, 0)
  
  # Only add the ";" to the final line, as some expressions
  # will already be multiline and not require a new ";"
  final_lines <- paste0(parsed_lines[length(parsed_lines)], ";")
  if (length(parsed_lines) > 1) {
    final_lines <- c(parsed_lines[1:(length(parsed_lines) - 1)],
                     final_lines)
  }
  
  return(final_lines)
}

# Recursive function that takes a character vector and parses the vector into
# a single character string that can be written to .cu kernel file
parse_expr <- function(expr_char_vec, var_names, depth, index = EVAL_DATA_INDEX,
                       type = DATA_EVAL, var_mapping = GPU_MAPPING,
                       allocate_intermediate_exprs = TRUE) {
  
  # Base case 1: a variable in the 
  var_index <- which(var_names == expr_char_vec)
  if (length(var_index) != 0) {
    
    # Evaluation dependent only on a single index of data
    if (type == DATA_EVAL){
      return(translate_variable(var_index, index = index, var_mapping = var_mapping))
    }
    
    # Evaluation dependent on the entire Rvar structure
    else {
      return(get_ref(var_index, var_mapping = var_mapping))
    }
  }
  
  # Base case 2: a numeric constant
  suppressWarnings(if (!is.na(as.numeric(expr_char_vec))) {
                     return(expr_char_vec)
                   }
  )
  
  # General case: The form of (fun ...)
  
  # Check basic math functions
  math_index <- which(startsWith(expr_char_vec, RAW_MATH_FUNS) == TRUE)
  if (length(math_index) != 0) {
    args_start <- nchar(RAW_MATH_FUNS[math_index]) + 2
    args <- identify_args(substr(expr_char_vec, args_start, nchar(expr_char_vec)))
    parsed_args <- lapply(args, parse_expr, var_names = var_names, depth = depth,
                          index = index, allocate_intermediate_exprs = allocate_intermediate_exprs)
    
    # Check special case of negative number
    if (length(parsed_args) == 1 & math_index == NEGATIVE_INDEX) {
      additional_lines <- get_additional_lines(parsed_args)
      parsed_num <- parsed_args[1][length(parsed_args[1])]
      cur_expr <- paste0("-(", parsed_num, ")")
      return(c(additional_lines, cur_expr))
    }
    
    # General case of the form op(arg1, arg2) where op is some element wise math
    additional_lines <- get_additional_lines(parsed_args)
    parsed_num1 <- parsed_args[1][length(parsed_args[1])]
    parsed_num2 <- parsed_args[2][length(parsed_args[2])]
    cur_expr <- paste0(PARSED_MATH_FUNS[math_index], "(", parsed_num1,
                       ", ", parsed_num2, ")")
    return(c(additional_lines, cur_expr))
  }
  
  # Check range function (i.e. ':')
  if (startsWith(expr_char_vec, RAW_RANGE_FUN)) {
    args_start <- nchar(RAW_RANGE_FUN) + 2
    args <- identify_args(substr(expr_char_vec, args_start, nchar(expr_char_vec)))
    parsed_args <- lapply(args, parse_expr, var_names = var_names, depth = depth,
                          index = DEFAULT_INDEX, allocate_intermediate_exprs = allocate_intermediate_exprs)
    additional_lines <- get_additional_lines(parsed_args)
    start <- parsed_args[1][length(parsed_args[1])]
    stop <- parsed_args[2][length(parsed_args[2])]
    cur_expr <- paste0(PARSED_RANGE_FUN, "(", start, ", ", stop, ", ", index, ")")
    return(c(additional_lines, cur_expr))
  }
  
  # Check matrix multiplication function
  if (startsWith(expr_char_vec, RAW_MAT_MUL_FUN)) {

    # If the expression is being parsed to identify lengths or dimensions
    # and not to write the kernel, return the intermediate evaluation
    # Rvar structure with memory access available on either GPU or CPU
    # dependent on the var_mapping
    if (expr_char_vec %in% g_int_eval_env$expr_to_eval_map &
        !allocate_intermediate_exprs) {
      var_index <- which(g_int_eval_env$expr_to_eval_map == expr_char_vec)
      return(get_ref(var_index, var_mapping = var_mapping))
    }
    args_start <- nchar(RAW_MAT_MUL_FUN) + 2
    args <- identify_args(substr(expr_char_vec, args_start, nchar(expr_char_vec)))
    additional_lines <- c()
    parsed_args <- c()
    
    # Check if either arg1 or arg2 are not simple variable expressions, if so allocate
    # intermediate Rvar used only for storing the sub expression evaluation data
    for (i in seq_along(args)) {
      if (!(args[i] %in% var_names)) {
        
        # Create additional lines of text to evaluate and save the intermediate
        # expression and update globally tracked variables needed to retrieve 
        # the intermediate evaluation by reference
        mapping <- CPU_INTERMEDIATE_EVAL_MAPPING
        if (allocate_intermediate_exprs) {
          additional_lines <- c(additional_lines,
                                get_intermediate_evaluation(args[i], var_names))
          mapping <- GPU_INTERMEDIATE_EVAL_MAPPING
          g_int_eval_env$expr_to_eval_map <- append(g_int_eval_env$expr_to_eval_map, args[i])
        }
        parsed_args[i] <- get_ref(g_int_eval_env$g_int_eval_count,
                                  var_mapping = mapping)
      }
      else {
        parsed_args[i] <- parse_expr(args[i], var_names, depth, type = REF_EVAL,
                                     allocate_intermediate_exprs = allocate_intermediate_exprs)
      }
    }
    cur_expr <- paste0(PARSED_MAT_MUL_FUN, "(", parsed_args[1], ", ", 
                       parsed_args[2], ", ", EVAL_DATA_INDEX, ")")

    return(c(additional_lines, cur_expr))
  }
  
  ## TODO CONDENSE ALL MATRIX PARSING TO ONE FUNCTION FOR MAJORITY OF 
  # REPEATED CODE
  
  # Check matrix transpose function
  if (startsWith(expr_char_vec, RAW_TRANSPOSE_FUN)) {
    
    # If the expression is being parsed to identify lengths or dimensions
    # and not to write the kernel, return the intermediate evaluation
    # Rvar structure with memory access available on either GPU or CPU
    # dependent on the var_mapping
    if (expr_char_vec %in% g_int_eval_env$expr_to_eval_map &
        !allocate_intermediate_exprs) {
      var_index <- which(g_int_eval_env$expr_to_eval_map == expr_char_vec)
      return(get_ref(var_index, var_mapping = var_mapping))
    }
    args_start <- nchar(RAW_TRANSPOSE_FUN) + 2
    args <- identify_args(substr(expr_char_vec, args_start, nchar(expr_char_vec)))
    additional_lines <- c()
    parsed_args <- c()
    
    # Check if matrix argument is not simple variable expressions, if so allocate
    # intermediate Rvar used only for storing the sub expression evaluation data
    if (!(args[1] %in% var_names)) {
      
      # Create additional lines of text to evaluate and save the intermediate
      # expression and update globally tracked variables needed to retrieve 
      # the intermediate evaluation by reference
      mapping <- CPU_INTERMEDIATE_EVAL_MAPPING
      if (allocate_intermediate_exprs) {
        additional_lines <- c(additional_lines,
                              get_intermediate_evaluation(args[1], var_names))
        mapping <- GPU_INTERMEDIATE_EVAL_MAPPING
        g_int_eval_env$expr_to_eval_map <- append(g_int_eval_env$expr_to_eval_map, args[1])
      }
      parsed_args[1] <- get_ref(g_int_eval_env$g_int_eval_count,
                                var_mapping = mapping)
    }
    else {
      parsed_args[1] <- parse_expr(args[1], var_names, depth, type = REF_EVAL,
                                   allocate_intermediate_exprs = allocate_intermediate_exprs)
    }
    
    cur_expr <- paste0(PARSED_TRANSPOSE_FUN, "(", parsed_args[1], ", ", 
                       EVAL_DATA_INDEX, ")")
    
    return(c(additional_lines, cur_expr))
  }
    
  # Check assignment function
  if (startsWith(expr_char_vec, RAW_ASSIGN_FUN)) {
    args_start <- nchar(RAW_ASSIGN_FUN) + 2
    args <- identify_args(substr(expr_char_vec, args_start, nchar(expr_char_vec)))
    var_index <- which(var_names == args[1])
    
    # Each thread can evaluate up to 22 indices in the expression, this is limited
    # by the __shared__ memory available to store the results of the evaluations 
    # before writing them to global memory associated with the first argument
    # of this expression
    eval_expr_lines <- parse_expr(args[2], var_names, depth,
                                  allocate_intermediate_exprs = allocate_intermediate_exprs)
    additional_lines <- get_additional_lines(list(eval_expr_lines))
    eval_expr <- eval_expr_lines[length(eval_expr_lines)]
    save_expr_len(expr_char_vec)
    assign_lines <- write_assign_loop(var_index, eval_expr)
    return(c(additional_lines, assign_lines))
  }
  
  # Check multiple run function (i.e. '{')
  if (startsWith(expr_char_vec, RAW_MULTI_EXPR_FUN)) {
    args_start <- nchar(RAW_MULTI_EXPR_FUN) + 2
    args <- identify_args(substr(expr_char_vec, args_start, nchar(expr_char_vec)))
    parsed_args <- lapply(args, parse_expr, var_names = var_names, depth = depth,
                          index = index, allocate_intermediate_exprs = allocate_intermediate_exprs)
    parsed_args <- c(lapply(parsed_args[1:(length(parsed_args) - 1)], append, values = SYNC_GRID),
                     parsed_args[length(parsed_args)])
    return(unlist(parsed_args, recursive = FALSE, use.names = FALSE))
  }
  
  # Check for loop function
  if (startsWith(expr_char_vec, RAW_FOR_FUN)) {
    args_start <- nchar(RAW_FOR_FUN) + 2
    args <- identify_args(substr(expr_char_vec, args_start, nchar(expr_char_vec)))
    return(write_for_loop(args, var_names, depth, index))
  }
}


write_assign_loop <- function(var_index, eval_expr, var_mapping = GPU_MAPPING) {
  
  # The var len that determines how many evaluation loops are needed
  # and the array that stores the results
  var_ref <- get_ref(var_index, var_mapping =  var_mapping)
  var_len <- paste0(var_ref, ".len")
  store_results <- paste0(STORE_RESULT, "[", SHARED_MEM_INDEX, "]")
  update_results <- paste0(var_ref, ".data[", EVAL_DATA_INDEX, "]")
  eval_index <- "_eval_index"
  
  # The actual lines of code for storing results
  initialize_SHARED_MEM_INDEX <- paste0(paste(SHARED_MEM_INDEX, PARSED_ASSIGN_FUN, THREAD_ID), ";")
  start_loop <- paste0("for (int ", eval_index, " = 0; ", eval_index, " < ", 
                       EVALS_PER_THREAD, "[", as.character(g_expr_env$g_expr_count - 1), "]; ", 
                       eval_index, "++) {")
  update_data_index <- paste(EVAL_DATA_INDEX, PARSED_ASSIGN_FUN, "grid_size", 
                             "*", eval_index, "+", GRID_ID)
  store_command <- paste(store_results, PARSED_ASSIGN_FUN, eval_expr)
  update_shared_index <- paste(SHARED_MEM_INDEX, "+=", THREADS_PER_BLOCK)
  store_loop <- c(initialize_SHARED_MEM_INDEX, start_loop,
                  paste0(indent_lines(c(update_data_index, store_command, 
                                        update_shared_index), 1), ";"),
                  "}")
  
  # The actual lines of code for updating the variable with
  # the stored results
  assignment_len_guard <- paste0("if (", EVAL_DATA_INDEX, " >= ", var_len, ") break")
  update_command <- paste(update_results, PARSED_ASSIGN_FUN, store_results)
  update_loop <- c(initialize_SHARED_MEM_INDEX, start_loop,
                   paste0(indent_lines(c(update_data_index, 
                                         assignment_len_guard,
                                         update_command, 
                                         update_shared_index), 1), ";"),
                   "}")
  
  return(c(store_loop, SYNC_GRID, update_loop))
}

# Function which writes compiled code lines to execute a for loop in 
# the syntax of R
write_for_loop <- function(args, var_names, depth, index) {
  
  # The compiled variable name that is used to iterate through the for loop,
  # starts at i1, then i2, then i3, etc, as depth increases (nested loops)
  iter_index <- paste0("i", as.character(depth))

  # The line of code which actually begins the loop, note that 'gpu_iter_lens[x]' is
  # the upper bound of the xth loop, gpu_iter_lens is a __constant__ memory storage array
  # of iteration lengths for all loops identified in these commands.  The lengths
  # are originally identified by cpu code using machine generated expressions
  # and stored in g_iter_lens[x], then copied to __constant__ memory for fast 
  # access on the GPU.
  loop_start_line <- paste0("for (int ", iter_index,  
                            " = 0; ", iter_index, " < gpu_iter_lens[", 
                            as.character(g_loop_env$g_loop_count),
                            "]; ", iter_index, "++) {")

  # Call the function which writes the necessary machine generated expression that
  # can then be called each time the commands are executed to identify the correct
  # iteration loop length
  save_iter_loop_expr(args[2])
  
  # The R variable that will be updated at each iteration to the evaluation of 
  # the second argument in the for expression at the index matching the current iteration
  var_index <- which(var_names == args[1])

  # Only the first thread of the entire grid needs to update the iteration variable,
  # as the iteration variable in an R for loop has a single element by defintion
  limit_line <- paste0("if (", GRID_ID," == 0) {")

  # The identified iteration variable is updated at DEFAULT_DATA_INDEX 
  # which is 0 in compiled code and 1 in R code.  
  update_iter_lines <- paste(translate_variable(var_index, mod_len = FALSE,
                                               index = DEFAULT_INDEX), 
                             PARSED_ASSIGN_FUN, parse_expr(args[2], var_names,
                                                           depth, index = iter_index),
                             ";")

  # We must sync the entire grid after updating the iteration variable, as other threads
  # which do not need to update the iteration variable could use the old value on this 
  # iteration without the synchronization
  update_iter_lines <- c(limit_line, indent_lines(update_iter_lines, 1), "}", SYNC_GRID)
  
  # Recursive call to parse the expression (can actually be multiple expressions using '{' function) 
  # executed by this for loop
  execute_line <- parse_expr(args[3], var_names, depth + 1, index)

  # The full lines of text for the parsed loop, includes the update to the iteration variable,
  # the execution of the body expression(s), and a synchronization command to ensure that
  # the full body has been completed by all threads before the next iteration is started
  body_text <- indent_lines(c(update_iter_lines, execute_line, SYNC_GRID))
  return(c(loop_start_line, indent_lines(body_text, depth = 1), "}"))
}

# Function which saves machine generated expressions to initialize the compiled values
# for the iteration loop lengths, the raw numeric value may change on separate executions,
# so it is necessary to evaluate the written expression at each call to update the 
# length of iterations for each loop included in the commands
save_iter_loop_expr <- function(arg) {
  g_loop_env$cur_expr <- arg
  update_expr <- substitute(g_loop_exprs[g_loop_count + 1] <- parse_expr_len(cur_expr, var_names))
  eval(update_expr, envir = g_loop_env)
  assign('g_loop_count', g_loop_env$g_loop_count + 1, envir = g_loop_env)
}

# Function which saves machine generated expressions to initialize the compiled values
# for the expression lengths, the raw numeric value may change on separate executions,
# so it is necessary to evaluate the written expression at each call to update the 
# length of expressions in the commands
save_expr_len <- function(arg) {
  g_expr_env$cur_expr <- arg
  update_expr <- substitute(g_expr_lens[g_expr_count + 1] <- parse_expr_len(cur_expr, var_names))
  eval(update_expr, envir = g_expr_env)
  assign('g_expr_count', g_expr_env$g_expr_count + 1, envir = g_expr_env)
}

# Function which saves machine generated expressions to initialize the compiled values
# for the intermediate evaluations, the raw numeric value may change on separate executions,
# so it is necessary to evaluate the written expression at each call to update the 
# length of intermediate evaluations included in the commands
save_int_eval <- function(arg) {
  g_int_eval_env$cur_expr <- arg
  g_int_eval_env$RDIM_TYPE <- RDIM_TYPE
  g_int_eval_env$CDIM_TYPE <- CDIM_TYPE
  update_expr <- substitute(g_int_eval_lens[g_int_eval_count + 1] <- parse_expr_len(cur_expr, var_names))
  eval(update_expr, envir = g_int_eval_env)
  update_expr <- substitute(g_int_eval_rdims[g_int_eval_count + 1] <- parse_expr_len(cur_expr, var_names, type = RDIM_TYPE))
  eval(update_expr, envir = g_int_eval_env)
  update_expr <- substitute(g_int_eval_cdims[g_int_eval_count + 1] <- parse_expr_len(cur_expr, var_names, type = CDIM_TYPE))
  eval(update_expr, envir = g_int_eval_env)
  assign('g_int_eval_count', g_int_eval_env$g_int_eval_count + 1, envir = g_int_eval_env)
}

# Recursive function which identifies the length of an expression by using R's 
# rules for operating on vectors/matrices of different sizes, the output of 
# this function is machine generated compiled code text
parse_expr_len <- function(expr_chars, var_names, type = LEN_TYPE) {
  
  # Base case 1: a variable in the 
  var_index <- which(var_names == expr_chars)
  if (length(var_index) != 0) {
    return(paste0(CPU_MAPPING, "[", as.character(var_index - 1), "].len"))
  }
  
  # Base case 2: a numeric constant
  suppressWarnings(if (!is.na(as.numeric(expr_chars))) {
                     return(as.character(1))
                   }
  )
  
  # Assignment operator `<-`
  if (startsWith(expr_chars, RAW_ASSIGN_FUN)) {
    args_start <- nchar(RAW_ASSIGN_FUN) + 2
    args <- identify_args(substr(expr_chars, args_start, nchar(expr_chars)))
    return(parse_expr_len(args[1], var_names))
  }
  
  # Basic elementwise math function
  math_index <- which(startsWith(expr_chars, RAW_MATH_FUNS) == TRUE)
  if (length(math_index) != 0) {
    args_start <- nchar(RAW_MATH_FUNS[math_index]) + 2
    args <- identify_args(substr(expr_chars, args_start, nchar(expr_chars)))
    
    # Check special case of negative number
    if (length(args) == 1 & math_index == NEGATIVE_INDEX) {
      return(parse_expr_len(args[1], var_names))
    }
    
    # Default case of op(a, b), with op some elementwise math function
    return(paste0("std::max(", parse_expr_len(args[1], var_names), ", ",
                  parse_expr_len(args[2], var_names), ")"))
  }
  
  # Range operator, i.e., ":"
  if (startsWith(expr_chars, RAW_RANGE_FUN)) {
    args_start <- nchar(RAW_RANGE_FUN) + 2
    args <- identify_args(substr(expr_chars, args_start, nchar(expr_chars)))
    # Depth should not be relevant for determining the length of a : expression,
    # as depth is only used in for loop parsing
    start <- parse_expr(args[1], var_names, depth = 0, index = DEFAULT_INDEX)
    stop <- parse_expr(args[2], var_names, depth = 0, index = DEFAULT_INDEX)
    return(paste0("std::floor(abs(", stop, " - ", start,  ")  + 1)"))
  }
  
  # Check matrix multiplication function
  if (startsWith(expr_chars, RAW_MAT_MUL_FUN)) {
    args_start <- nchar(RAW_MAT_MUL_FUN) + 2
    args <- identify_args(substr(expr_chars, args_start, nchar(expr_chars)))
    if ((args[1] %in% var_names)) mapping <- CPU_MAPPING
    else mapping <- CPU_INTERMEDIATE_EVAL_MAPPING 
    arg1 <- parse_expr(args[1], var_names, depth, type = REF_EVAL, var_mapping = mapping,
                       allocate_intermediate_exprs = FALSE)
    
    if ((args[2] %in% var_names)) mapping <- CPU_MAPPING
    else mapping <- CPU_INTERMEDIATE_EVAL_MAPPING 
    arg2 <- parse_expr(args[2], var_names, depth, type = REF_EVAL, var_mapping = mapping,
                       allocate_intermediate_exprs = FALSE)
    if (type == RDIM_TYPE) {
      return(paste0(arg1, ".rdim"))
    }
    else if (type == CDIM_TYPE) {
      return(paste0(arg2, ".cdim"))
    }
    return(paste0(arg1, ".rdim * ", arg2, ".cdim"))
  }
  
  # Check transpose function
  if (startsWith(expr_chars, RAW_TRANSPOSE_FUN)) {
    args_start <- nchar(RAW_TRANSPOSE_FUN) + 2
    args <- identify_args(substr(expr_chars, args_start, nchar(expr_chars)))
    if ((args[1] %in% var_names)) mapping <- CPU_MAPPING
    else mapping <- CPU_INTERMEDIATE_EVAL_MAPPING 
    arg1 <- parse_expr(args[1], var_names, depth, type = REF_EVAL, var_mapping = mapping,
                       allocate_intermediate_exprs = FALSE)
    if (type == RDIM_TYPE) {
      return(paste0(arg1, ".cdim"))
    }
    else if (type == CDIM_TYPE) {
      return(paste0(arg1, ".rdim"))
    }
    return(paste0(arg1, ".rdim * ", arg1, ".cdim"))
  }
  
}

identify_arg <- function(expr_char_vec) {
  open_count <- 0
  for (index in 1:nchar(expr_char_vec)) {
    char_at <- substr(expr_char_vec, index, index)
    if (char_at == DELIM & open_count == 0) {
      return(index - 1)
    }
    else if (char_at == OPEN_EXPR) {
      open_count <- open_count + 1
    }
    else if (char_at == CLOSE_EXPR) {
      if (open_count == 0) {
        return(index - 1)
      }
      open_count <- open_count - 1
    }
  }
}

get_ref <- function(var_num, var_mapping = GPU_MAPPING) {
  paste0(var_mapping, "[", as.character(var_num - 1), "]")
}

translate_variable <- function(var_num, mod_len = TRUE, index = GRID_ID,
                               var_mapping = GPU_MAPPING) {
  if (index == DEFAULT_INDEX) { 
    mod_len <- FALSE
  }
  var_struct <- get_ref(var_num, var_mapping)
  if (mod_len) {
    return(paste0(var_struct, ".", DATA_FIELD, "[", 
                  index, " % ", var_struct, ".", DATA_LENGTH, "]"))
  }
  return(paste0(var_struct, ".", DATA_FIELD, "[", index, "]"))
}

identify_args <- function(expr_char_vec) {
  cur_pos <- 1
  args <- c()
  while (cur_pos < nchar(expr_char_vec)) {
    arg_len <- identify_arg(substr(expr_char_vec, cur_pos, nchar(expr_char_vec)))
    arg_chars <- substr(expr_char_vec, cur_pos, cur_pos + arg_len - 1)
    args <- c(args, arg_chars)
    cur_pos <- cur_pos + arg_len + 1
  }
  return(args)
}

# Puts R string in a form that can be passed to C
vectorize_string <- function(input_string) {
  as.vector(strsplit(input_string, ""))[[1]]
}

# Recursive function that converts an input expression
# into a vector of single chars which can be parsed
# in the R code to write machine generated code
# to replicate the native R execution on the GPU
racket_char_vec <- function(input_expr) {
  if (is.numeric(input_expr)) {
    return(vectorize_string(deparse(input_expr)))
  }
  else if (is.symbol(input_expr)) {
    return(vectorize_string(as.character(input_expr)))
  }
  else if (is.function(eval(input_expr[[1]]))) {
    function_string <- vectorize_string(as.character(input_expr))
    if (function_string[1] == "(") function_string <- c('p', 'a', 'r')
    expr_char_vec <- c("(", function_string)
    for (i in 2:length(input_expr)) {
      expr_char_vec <- append(append(expr_char_vec, c(" ")),
                              racket_char_vec(input_expr[[i]]))
    }
    return(append(expr_char_vec, ")"))
  }
  print("ERROR: Expression unmatched ")
  print(as.character(input_expr))
  return(NULL)
}
