% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse_expr.R
\name{parse_expr}
\alias{parse_expr}
\title{Recursively parse character expression to generate machine written compiled code.}
\usage{
parse_expr(
  expr_chars,
  var_names,
  index = c("_eval_data_index", "_shared_mem_index", "DEFAULT_DATA_INDEX", paste0("i",
    0:9)),
  type = c("data", "ref"),
  var_mapping = c("gpu_vars", "g_vars", "gpu_int_evals", "g_int_evals"),
  depth = 0,
  allocate_intermediate_exprs = TRUE
)
}
\arguments{
\item{expr_chars}{A character string that represents the expression currently
being parsed.  This expression string will have the general form of 
(fun arg1 arg2 ... argn) with any number of args.}

\item{var_names}{A character vector with the names of all variables that 
are included in the compiled commands.  This is used to identify the index
of the Rvar structure in the compiled global array.}

\item{index}{An integer index of evaluation which, if applicable, determines
what index of data is used from an Rvar structure in the compiled memory.}

\item{type}{A character string which, if applicable, determines whether 
an reference to an entire Rvar structure or an index of data in that Rvar
structure is parsed.}

\item{var_mapping}{A character string which, if applicable, controls which
type of memory and Rvar is parsed.  The memory may be accessible on either 
the GPU or the CPU, but not both, and the Rvar may be part of the global 
array that holds all R variables read into memory, or part of the intermediate
evaluations array used to store intermediate evaluation matrix arguments.}

\item{depth}{An integer representing the depth of loop iterations currently
being used. This determines the name of the iteration variable used.}

\item{allocate_intermediate_exprs}{Boolean flag which, if TRUE, results in 
allocating additional intermediate evaluation variables in compiled memory
to save nested matrix arguments and prevent repeated evaluations through
recursion. If FALSE, this call to parse_expr is being used only for 
dimension parsing, and so we do not reallocated nested matrix arguments, as
dimension parsing occurs after the initial parsing and the allocation is 
already complete.}
}
\value{
List of start and end indices for the specified flag_str
}
\description{
Recursive function that takes a character string and parses the vector into
a vector of potentially multiple character strings of machine generated 
code to written to kernel.cu. The allocation flag variable determines 
whether this is the initial top level call that creates code for the 
kernel function, in which case additional intermediate evaluations will be
allocated if matrix arguments are not direct Rvar references. If instead this
call is only to parse dimensional information, allocate flag will be FALSE
and no additional intermediate evaluations will be allocated.
}
\examples{
find_start_end_lines("Kernel")
}
